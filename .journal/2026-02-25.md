# Journal - 2026-02-25

---

## 2026-02-25 00:45:00 - tauri-plugin-libsql Implementation

### Core Decision/Topic
Implemented a complete Tauri plugin for libsql with encryption support and Drizzle ORM integration, serving as an alternative to @tauri-apps/plugin-sql with native encryption capabilities.

### Options Considered

1. **Fork @tauri-apps/plugin-sql and add encryption**
   - Pros: Maintains full API compatibility
   - Cons: sqlx doesn't support libsql encryption; would require significant changes

2. **Use sqlx-cipher or sqlcipher directly**
   - Pros: More established encryption solutions
   - Cons: Additional native dependencies, complex build process

3. **Use libsql crate with encryption feature** (CHOSEN)
   - Pros: Native encryption support, simpler API, official Turso library
   - Cons: Smaller community than sqlx, limited to SQLite only

### Final Decision & Rationale
Chose libsql crate because:
- **Native encryption**: libsql has built-in encryption via the `encryption` feature flag
- **Modern API**: Builder pattern with `encryption_config()` method
- **Simpler implementation**: No need for complex FFI bindings
- **Active development**: Maintained by Turso with regular updates

### Key Changes Made

**Rust Backend:**
- `Cargo.toml` - Added libsql 0.9.29 with encryption + core features, serde_json, indexmap, tokio, futures, bytes
- `src/wrapper.rs` - DbConnection wrapper using `libsql::Builder::new_local().encryption_config().build().await`
- `src/decode.rs` - Type conversion from libsql::Value to serde_json::Value
- `src/commands.rs` - Command handlers: load, execute, select, close, ping
- `src/models.rs` - Cipher enum (AES-256-CBC), EncryptionConfig, LoadOptions, QueryResult
- `src/error.rs` - Error types with libsql::Error integration
- `src/lib.rs` - Plugin builder with DbInstances state management

**JavaScript/TypeScript Frontend:**
- `guest-js/index.ts` - Database class matching @tauri-apps/plugin-sql API
- `guest-js/drizzle.ts` - `createDrizzleProxy()` and `createDrizzleProxyWithEncryption()` helpers

**Configuration:**
- `build.rs` - Command registration for Tauri plugin generation
- `permissions/` - Permission files for load, execute, select, close, ping

### Architecture

```
Frontend (JS/TS)              Tauri Plugin (Rust)
┌─────────────────┐          ┌────────────────────┐
│ Database class  │          │ commands.rs        │
│ drizzle.ts      │──────────│ wrapper.rs         │
└─────────────────┘  invoke  │ DbInstances        │
                             └─────────┬──────────┘
                                       │
                             ┌─────────▼──────────┐
                             │ libsql crate       │
                             │ (encryption feat)  │
                             └────────────────────┘
```

### Encryption Implementation
- Uses libsql's `EncryptionConfig::new(Cipher::Aes256Cbc, Bytes)`
- Key passed as Vec<u8> from frontend, converted to bytes::Bytes
- Connection created via Builder pattern with encryption_config()

### Drizzle ORM Integration
- Implements sqlite-proxy callback pattern
- `createDrizzleProxy(path)` - Standard connection
- `createDrizzleProxyWithEncryption(options)` - Encrypted connection
- Transforms row objects to arrays for Drizzle compatibility

### Future Considerations
1. **Additional cipher support**: Currently only AES-256-CBC; libsql supports more ciphers
2. **Migration system**: Add migration support like @tauri-apps/plugin-sql
3. **Replication support**: libsql supports embedded replicas - could be exposed
4. **Transaction API**: Add explicit transaction support
5. **Connection pooling**: Currently one connection per database path
6. **Mobile testing**: iOS/Android implementations need verification

### References
- Official Tauri SQL plugin: `references/tauri-plugins-workspace/plugins/sql/`
- Drizzle proxy example: `references/drizzle-sqlite-proxy/`
- libsql repo: https://github.com/tursodatabase/libsql

---


## 2026-02-25 03:08:00 - Drizzle ORM Migration System

### Core Decision/Topic
Implemented a custom migration system for Drizzle ORM with sqlite-proxy driver, since the standard `drizzle-kit migrate` doesn't work with the proxy pattern used in Tauri apps.

### Problem
The app was failing with "no such table: todos" on first run because:
1. The database file was created but tables didn't exist
2. `runMigrations()` was being called before `Database.load()` created the connection
3. Standard drizzle-kit migrations require direct database access, not available through the proxy

### Solution
Built a custom migration runner (`src/lib/migrate.ts`) that:
1. Uses Vite's `import.meta.glob` to bundle migration SQL files at build time
2. Tracks applied migrations in a `__drizzle_migrations` table
3. Executes pending migrations via Tauri invoke commands
4. Runs migrations AFTER database is loaded but BEFORE queries

### Key Changes Made

**Demo App (`examples/tauri-app/`):**
- `drizzle.config.ts` - Configured for SQLite dialect with schema path
- `drizzle/0000_*.sql` - Generated migration creating todos table
- `src/lib/migrate.ts` - Custom migration runner for sqlite-proxy
- `src/lib/schema.ts` - Added `TodoUpdate` helper type for Drizzle type inference
- `src/App.svelte` - Fixed startup sequence: `Database.load()` → `runMigrations()` → `loadTodos()`

**Package.json cleanup:**
- Moved `drizzle-kit` from root to example app devDependencies
- Removed `drizzle-orm` from root (only needed for demo)

### Migration Workflow

**For developers making schema changes:**
```bash
# 1. Edit src/lib/schema.ts
# 2. Generate new migration
npx drizzle-kit generate
# 3. Migrations auto-run on next app startup
```

**Startup sequence:**
1. `Database.load(dbPath)` - Creates database file/connection
2. `runMigrations(dbPath)` - Creates __drizzle_migrations table, runs pending migrations
3. `loadTodos()` - Queries the now-existing tables

### Technical Details

**Migration tracking table:**
```sql
CREATE TABLE __drizzle_migrations (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  hash TEXT NOT NULL UNIQUE,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

**Why not standard drizzle-kit migrate?**
- Standard `migrate()` requires direct filesystem/database access
- sqlite-proxy uses callbacks through Tauri's invoke system
- Custom runner allows bundling SQL files with the app

### Future Considerations
1. **Rollback support**: Currently only supports forward migrations
2. **Migration validation**: Could add checksum validation for migration files
3. **Seeding**: Could add data seeding alongside schema migrations
4. **Multiple databases**: Migration runner currently assumes single database

---

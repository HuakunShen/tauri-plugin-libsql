# Journal - 2026-02-25

---

## 2026-02-25 00:45:00 - tauri-plugin-libsql Implementation

### Core Decision/Topic
Implemented a complete Tauri plugin for libsql with encryption support and Drizzle ORM integration, serving as an alternative to @tauri-apps/plugin-sql with native encryption capabilities.

### Options Considered

1. **Fork @tauri-apps/plugin-sql and add encryption**
   - Pros: Maintains full API compatibility
   - Cons: sqlx doesn't support libsql encryption; would require significant changes

2. **Use sqlx-cipher or sqlcipher directly**
   - Pros: More established encryption solutions
   - Cons: Additional native dependencies, complex build process

3. **Use libsql crate with encryption feature** (CHOSEN)
   - Pros: Native encryption support, simpler API, official Turso library
   - Cons: Smaller community than sqlx, limited to SQLite only

### Final Decision & Rationale
Chose libsql crate because:
- **Native encryption**: libsql has built-in encryption via the `encryption` feature flag
- **Modern API**: Builder pattern with `encryption_config()` method
- **Simpler implementation**: No need for complex FFI bindings
- **Active development**: Maintained by Turso with regular updates

### Key Changes Made

**Rust Backend:**
- `Cargo.toml` - Added libsql 0.9.29 with encryption + core features, serde_json, indexmap, tokio, futures, bytes
- `src/wrapper.rs` - DbConnection wrapper using `libsql::Builder::new_local().encryption_config().build().await`
- `src/decode.rs` - Type conversion from libsql::Value to serde_json::Value
- `src/commands.rs` - Command handlers: load, execute, select, close, ping
- `src/models.rs` - Cipher enum (AES-256-CBC), EncryptionConfig, LoadOptions, QueryResult
- `src/error.rs` - Error types with libsql::Error integration
- `src/lib.rs` - Plugin builder with DbInstances state management

**JavaScript/TypeScript Frontend:**
- `guest-js/index.ts` - Database class matching @tauri-apps/plugin-sql API
- `guest-js/drizzle.ts` - `createDrizzleProxy()` and `createDrizzleProxyWithEncryption()` helpers

**Configuration:**
- `build.rs` - Command registration for Tauri plugin generation
- `permissions/` - Permission files for load, execute, select, close, ping

### Architecture

```
Frontend (JS/TS)              Tauri Plugin (Rust)
┌─────────────────┐          ┌────────────────────┐
│ Database class  │          │ commands.rs        │
│ drizzle.ts      │──────────│ wrapper.rs         │
└─────────────────┘  invoke  │ DbInstances        │
                             └─────────┬──────────┘
                                       │
                             ┌─────────▼──────────┐
                             │ libsql crate       │
                             │ (encryption feat)  │
                             └────────────────────┘
```

### Encryption Implementation
- Uses libsql's `EncryptionConfig::new(Cipher::Aes256Cbc, Bytes)`
- Key passed as Vec<u8> from frontend, converted to bytes::Bytes
- Connection created via Builder pattern with encryption_config()

### Drizzle ORM Integration
- Implements sqlite-proxy callback pattern
- `createDrizzleProxy(path)` - Standard connection
- `createDrizzleProxyWithEncryption(options)` - Encrypted connection
- Transforms row objects to arrays for Drizzle compatibility

### Future Considerations
1. **Additional cipher support**: Currently only AES-256-CBC; libsql supports more ciphers
2. **Migration system**: Add migration support like @tauri-apps/plugin-sql
3. **Replication support**: libsql supports embedded replicas - could be exposed
4. **Transaction API**: Add explicit transaction support
5. **Connection pooling**: Currently one connection per database path
6. **Mobile testing**: iOS/Android implementations need verification

### References
- Official Tauri SQL plugin: `references/tauri-plugins-workspace/plugins/sql/`
- Drizzle proxy example: `references/drizzle-sqlite-proxy/`
- libsql repo: https://github.com/tursodatabase/libsql

---


## 2026-02-25 03:08:00 - Drizzle ORM Migration System

### Core Decision/Topic
Implemented a custom migration system for Drizzle ORM with sqlite-proxy driver, since the standard `drizzle-kit migrate` doesn't work with the proxy pattern used in Tauri apps.

### Problem
The app was failing with "no such table: todos" on first run because:
1. The database file was created but tables didn't exist
2. `runMigrations()` was being called before `Database.load()` created the connection
3. Standard drizzle-kit migrations require direct database access, not available through the proxy

### Solution
Built a custom migration runner (`src/lib/migrate.ts`) that:
1. Uses Vite's `import.meta.glob` to bundle migration SQL files at build time
2. Tracks applied migrations in a `__drizzle_migrations` table
3. Executes pending migrations via Tauri invoke commands
4. Runs migrations AFTER database is loaded but BEFORE queries

### Key Changes Made

**Demo App (`examples/tauri-app/`):**
- `drizzle.config.ts` - Configured for SQLite dialect with schema path
- `drizzle/0000_*.sql` - Generated migration creating todos table
- `src/lib/migrate.ts` - Custom migration runner for sqlite-proxy
- `src/lib/schema.ts` - Added `TodoUpdate` helper type for Drizzle type inference
- `src/App.svelte` - Fixed startup sequence: `Database.load()` → `runMigrations()` → `loadTodos()`

**Package.json cleanup:**
- Moved `drizzle-kit` from root to example app devDependencies
- Removed `drizzle-orm` from root (only needed for demo)

### Migration Workflow

**For developers making schema changes:**
```bash
# 1. Edit src/lib/schema.ts
# 2. Generate new migration
npx drizzle-kit generate
# 3. Migrations auto-run on next app startup
```

**Startup sequence:**
1. `Database.load(dbPath)` - Creates database file/connection
2. `runMigrations(dbPath)` - Creates __drizzle_migrations table, runs pending migrations
3. `loadTodos()` - Queries the now-existing tables

### Technical Details

**Migration tracking table:**
```sql
CREATE TABLE __drizzle_migrations (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  hash TEXT NOT NULL UNIQUE,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

**Why not standard drizzle-kit migrate?**
- Standard `migrate()` requires direct filesystem/database access
- sqlite-proxy uses callbacks through Tauri's invoke system
- Custom runner allows bundling SQL files with the app

### Future Considerations
1. **Rollback support**: Currently only supports forward migrations
2. **Migration validation**: Could add checksum validation for migration files
3. **Seeding**: Could add data seeding alongside schema migrations
4. **Multiple databases**: Migration runner currently assumes single database

---

## 2026-02-25 05:37:00 - Turso Sync, Two-Panel Demo, and Bug Fixes

### Core Decision/Topic

Extended the plugin with Turso embedded replica support (`batch` + `sync` commands), rewrote the demo as a two-panel side-by-side app (Local SQLite ↔ Turso), and resolved several correctness issues discovered during integration testing.

---

### Feature: batch() Command

**Problem**: `migrate()` previously sent each DDL statement individually via `execute()`. With libsql embedded replicas, DDL through the replica layer needs to be transactional or it can silently produce inconsistent state (tables created in tracking but not in DB).

**Solution**: Added a `batch()` command that wraps multiple SQL statements in an explicit `BEGIN` / `COMMIT` with per-statement `ROLLBACK` on failure. Note: `execute_batch()` from libsql was tried first but doesn't correctly route writes through the embedded replica layer — individual `execute()` calls inside an explicit transaction work correctly.

**Files**: `src/commands.rs`, `src/wrapper.rs`, `guest-js/index.ts`, `permissions/autogenerated/commands/batch.toml`, `permissions/default.toml`

---

### Feature: sync() Command + Turso Embedded Replica Support

**Options Considered**:
1. **Pure remote mode** — all queries hit the network. Fast to implement but defeats the purpose of local-first.
2. **Embedded replica** (CHOSEN) — local SQLite file, initial sync on `Database.load()`, manual `sync()` pulls incremental changes. Reads are always local; writes route through the remote.

**Decision**: Embedded replica is the correct default for Tauri apps. The whole value proposition of libsql over vanilla SQLite is offline-capable, eventually-consistent sync without requiring the user to manage two databases.

**Panic protection**: libsql's builder internally calls `unwrap()` on the sync URL during URI parsing. A malformed URL (or whitespace in credentials) causes a Rust panic rather than returning an `Err`. In Tauri, a panic inside an `async` command causes the IPC to hang forever — the JS `await` never resolves, leaving the UI stuck on `loading = true`. Fixed by wrapping the entire builder async block with `AssertUnwindSafe(...).catch_unwind().await`, converting any panic into a proper `Error::InvalidDbUrl`.

**Files**: `src/commands.rs`, `src/wrapper.rs` (new `open_replica`, `open_remote`, `do_sync`), `guest-js/index.ts` (`sync()` method), `permissions/autogenerated/commands/sync.toml`

---

### Feature: Two-Panel Demo App

**Problem**: The original demo was a single local-only todo list. After adding Turso support, there was no way to visually compare local vs. remote behavior.

**Decision**: Split the app into two independent columns rendered side by side:
- **Left**: Local SQLite (`todos.db`) — always present
- **Right**: Turso embedded replica (`todos-turso.db`) — shown when connected; replaced by a connect form otherwise

**Key implementation details**:
- Separate DB files (`todos.db` vs `todos-turso.db`) avoid a "metadata file missing" error that occurs when libsql tries to open a plain SQLite file as an embedded replica or vice versa.
- Turso credentials are stored in `localStorage` and read synchronously at module init (not `onMount`) to avoid async prop timing issues that prevented credentials from being visible when the Turso `TodoList` first mounted.
- The `TodoList` component is fully self-contained — it accepts `dbFile`, `syncUrl`, `authToken`, `position`, `onDisconnect` props and manages its own DB lifecycle in `onMount`.
- `position` prop routes sonner toasts to bottom-left (local) or bottom-right (Turso) so both panels' events are visually distinct.

**Files**: `examples/todo-list/src/App.svelte` (rewritten), `examples/todo-list/src/lib/TodoList.svelte` (new), `examples/todo-list/src/lib/db.ts` (simplified to factory fn), `examples/todo-list/src-tauri/Cargo.toml` (added `replication` feature)

---

### Feature: Reset DB Button

**Problem**: When a user manually deletes tables in the Turso console without clearing `__drizzle_migrations`, the next `migrate()` call sees the migration as already applied and skips re-creating the table. Result: "no such table: todos" on startup with no recovery path.

**Solution**: Added a "Reset DB" button that drops `todos` and `__drizzle_migrations`, then re-runs all migrations from scratch. Always visible (not gated on `!error`) so it's accessible even after a fatal load error.

---

### Bug Fixes

| Bug | Root Cause | Fix |
|-----|-----------|-----|
| `loading` stuck forever on bad Turso URL | libsql builder panics on invalid URI; Tauri IPC never responds | `AssertUnwindSafe(...).catch_unwind()` in `connect()` |
| CRUD errors replaced entire todo form with Alert | `error` state used for both fatal (load) and transient (action) errors; `{:else if error}` hides the form | Removed `error =` assignments from action functions; toasts handle transient errors |
| `{#if dbInstance}` didn't update in template | `dbInstance` declared `let x = null` without `$state` | Changed to `let dbInstance = $state<Database | null>(null)` |
| `dbPath`/`isTurso` captured stale prop values | Declared as `const` from props instead of reactive | Changed to `$derived(...)` |
| `batch()` left transaction dirty on COMMIT failure | Only ROLLBACK on query failure, not on COMMIT failure | Added ROLLBACK on COMMIT failure |
| `do_sync` used wrong error variant | Used `Error::InvalidDbUrl` for a non-URL error | Added `Error::OperationNotSupported` variant |

---

### Svelte 5 Patterns Learned

- Props captured as `const` at module level produce `state_referenced_locally` warnings and stale values. Use `$derived(prop)` for values derived from props.
- `$state` is required on any `let` that affects the template reactively. Non-state mutable lets work fine inside functions but won't trigger template updates.
- `on:submit` → `onsubmit` (event handlers are now regular attributes in Svelte 5).

---

### Future Considerations

1. **Auto-sync on network reconnect**: Currently sync is manual. Could use Tauri's network-status event to trigger `db.sync()` automatically.
2. **Conflict resolution UI**: Embedded replica does last-write-wins; no UI for conflict visibility.
3. **`execute_batch` investigation**: Worth filing an issue with tursodatabase/libsql — `execute_batch` should work through the replica write path but doesn't in 0.9.29.
4. **Idempotent `load` TOCTOU**: The `contains_key` check and subsequent `insert` in `commands::load` have a narrow race window. Low priority for a single-user Tauri app.

---
